<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8" />
  <title>Snake con Sprites - Práctica 4</title>
  <style>
    body { font-family: Arial, sans-serif; text-align:center; background:#d9c39a; margin:12px; }
    canvas { border:3px solid #444; display:block; margin:12px auto; border-radius:8px; background:#000; }
    #controls{ margin-top:8px; }
    #controls button{ padding:6px 10px; }
  </style>
</head>
<body>
  <h2>Jueguito de gusano
  </h2>
  <canvas id="webglcanvas" width="600" height="600"></canvas>

  <div id="controls">
    Puntaje: <span id="score">0</span>
    <button id="btnRestart">Reiniciar</button>
  </div>

 
  <img id="imgSheet" src="./imagen/1234t.png" hidden>
  <img id="imgApple" src="./imagen/manzanat.png" hidden>
  <img id="imgBG" src="./imagen/ces.jpg" hidden>

  <script id="vs" type="vertex">
    #version 300 es
    precision mediump float;
    layout(location = 0) in vec2 aVertices;
    layout(location = 1) in vec2 aUV;
    uniform mat4 uMatrizProyeccion;
    uniform mat4 uMatrizVista;
    uniform mat4 uMatrizModelo;
    uniform vec2 uUVOffset;
    uniform vec2 uUVScale;
    out vec2 vCoordenadasDeTextura;
    void main() {
      vCoordenadasDeTextura = aUV * uUVScale + uUVOffset;
      gl_Position = uMatrizProyeccion * uMatrizVista * uMatrizModelo * vec4(aVertices, 0.0, 1.0);
    }
  </script>

  <script id="fs" type="fragment">
    #version 300 es
    precision mediump float;
    in vec2 vCoordenadasDeTextura;
    uniform sampler2D uUnidadDeTextura;
    uniform float uHasTexture; 
    uniform vec4 uColor;
    out vec4 color;
    void main() {
      if(uHasTexture > 0.5) {
        color = texture(uUnidadDeTextura, vCoordenadasDeTextura) * uColor;
      } else {
        color = uColor;
      }
    }
  </script>

  <script>
    "use strict";

    /* --------------------- matrices y utilidades --------------------- */
    function identidad(r) {
      for (let i=0;i<16;i++) r[i]=(i%5==0)?1:0;
    }
    function multiplica(c,a,b){
      let r=new Array(16);
      for(let i=0;i<4;i++) for(let j=0;j<4;j++){
        let s=0;
        for(let k=0;k<4;k++) s += a[i+k*4]*b[k+j*4];
        r[i+j*4]=s;
      }
      for(let i=0;i<16;i++) c[i]=r[i];
    }
    function traslacion(matriz, tx, ty, tz){
      let r=new Array(16); identidad(r);
      r[12]=tx; r[13]=ty; r[14]=tz;
      multiplica(matriz, matriz, r);
    }
    function escalacion(matriz, sx, sy, sz){
      let r=new Array(16); identidad(r);
      r[0]=sx; r[5]=sy; r[10]=sz;
      multiplica(matriz, matriz, r);
    }
    function rotacionZ(matriz, ang){
      let c=Math.cos(ang), s=Math.sin(ang);
      let r=new Array(16); identidad(r);
      r[0]=c; r[4]=-s; r[1]=s; r[5]=c;
      multiplica(matriz, matriz, r);
    }
    function ortho(r, izq, der, abj, arr, cerca, lejos){
      r[0] = 2/(der - izq); r[4] = 0; r[8]=0; r[12]=-(der+izq)/(der-izq);
      r[1] = 0; r[5] = 2/(arr - abj); r[9]=0; r[13]=-(arr+abj)/(arr-abj);
      r[2] = 0; r[6] = 0; r[10] = -2/(lejos - cerca); r[14] = -(lejos+cerca)/(lejos-cerca);
      r[3]=0; r[7]=0; r[11]=0; r[15]=1;
    }

    /* --------------------- GL setup --------------------- */
    const canvas = document.getElementById("webglcanvas");
    const gl = canvas.getContext("webgl2");
    
    if(!gl){ alert("WebGL2 no disponible"); throw "no webgl2"; }

    function compilar(type, src){
      const sh = gl.createShader(type);
      gl.shaderSource(sh, src);
      gl.compileShader(sh);
      if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){
        console.error(gl.getShaderInfoLog(sh));
      }
      return sh;
    }
    const vs = compilar(gl.VERTEX_SHADER, document.getElementById("vs").text.trim());
    const fs = compilar(gl.FRAGMENT_SHADER, document.getElementById("fs").text.trim());
    const prog = gl.createProgram();
    gl.attachShader(prog, vs); gl.attachShader(prog, fs); gl.linkProgram(prog); gl.useProgram(prog);

    
    const uMatrizProyeccion = gl.getUniformLocation(prog, "uMatrizProyeccion");
    const uMatrizVista = gl.getUniformLocation(prog, "uMatrizVista");
    const uMatrizModelo = gl.getUniformLocation(prog, "uMatrizModelo");
    const uUnidadDeTextura = gl.getUniformLocation(prog, "uUnidadDeTextura");
    const uUVOffset = gl.getUniformLocation(prog, "uUVOffset");
    const uUVScale = gl.getUniformLocation(prog, "uUVScale");
    const uHasTexture = gl.getUniformLocation(prog, "uHasTexture");
    const uColor = gl.getUniformLocation(prog, "uColor");

    gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    
    const quadData = new Float32Array([
      -0.5, -0.5,  0.0, 0.0,
       0.5, -0.5,  1.0, 0.0,
       0.5,  0.5,  1.0, 1.0,
      -0.5,  0.5,  0.0, 1.0
    ]);
    const quadVAO = gl.createVertexArray();
    gl.bindVertexArray(quadVAO);
    const qb = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, qb);
    gl.bufferData(gl.ARRAY_BUFFER, quadData, gl.STATIC_DRAW);
    const stride = 4 * Float32Array.BYTES_PER_ELEMENT;
    gl.enableVertexAttribArray(0); gl.vertexAttribPointer(0,2,gl.FLOAT,false,stride,0);
    gl.enableVertexAttribArray(1); gl.vertexAttribPointer(1,2,gl.FLOAT,false,stride,2*Float32Array.BYTES_PER_ELEMENT);
    gl.bindVertexArray(null);

    /* ---------- proyección y vista ---------- */
    let MatrizProyeccion = new Array(16), MatrizVista = new Array(16), MatrizModelo = new Array(16);
    const aspect = canvas.width / canvas.height;
      if (aspect >= 1)
    ortho(MatrizProyeccion, -5 * aspect, 5 * aspect, -5, 5, -1, 1);
      else
    ortho(MatrizProyeccion, -5, 5, -5 / aspect, 5 / aspect, -1, 1);

    identidad(MatrizVista);
    gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);
    gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);

    /* ---------------- game params) ---------------- */
    const outerHalf = 4.0;
    const GRID_SIZE = 12;
    const CELL_WORLD = (outerHalf*2)/GRID_SIZE;
    const GRID_LEFT = -outerHalf + CELL_WORLD/2;
    const GRID_TOP = outerHalf - CELL_WORLD/2;

    let snake = [];
    let dir = {x:1,y:0}, pendingDir = null;
    let food = null, tickInterval = 300, tickHandle = null, running=false, score=0;

    /* ----------------textures from <img> elements ---------------- */
    function createTextureFromImg(imgElement){
      const t = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, t);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); // convenient for UV math
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, imgElement);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.bindTexture(gl.TEXTURE_2D, null);
      return t;
    }

   
    let texSheet=null, texApple=null, texBG=null;
    // and meta for sheet
    const sheetCols = 3, sheetRows = 4;

    
    function initTexturesAndStart(){
  const imgS = document.getElementById("imgSheet");
  const imgA = document.getElementById("imgApple");
  const imgB = document.getElementById("imgBG");
  
  // Verificar que la imagen se cargó con las dimensiones correctas
  console.log("Sprite sheet dimensions:", imgS.naturalWidth, "x", imgS.naturalHeight);
  
  // create GL textures
  texSheet = createTextureFromImg(imgS);
  texApple = createTextureFromImg(imgA);
  texBG = createTextureFromImg(imgB);

  // start game
  resetGame();
  requestAnimationFrame(loop);
}
    // if images are already loaded, call init immediately
    const imgSdom = document.getElementById("imgSheet");
    if(imgSdom.complete) {
      // ensure apple/bg are loaded too
      window.setTimeout(initTexturesAndStart, 10);
    } else {
      imgSdom.onload = initTexturesAndStart;
    }

    /* ---------------- game utilities ---------------- */
    function cellToWorld(col,row){ return { x: GRID_LEFT + col * CELL_WORLD, y: GRID_TOP - row * CELL_WORLD }; }
    function spawnFood(){
      while(true){
        const fx = Math.floor(Math.random()*GRID_SIZE);
        const fy = Math.floor(Math.random()*GRID_SIZE);
        if(!snake.some(s=>s.x===fx && s.y===fy)){ food={x:fx,y:fy}; return; }
      }
    }

    function resetGame(){
      snake = [];
      const mid = Math.floor(GRID_SIZE/2);
      // YOUR REQUEST: visual order [ cola | cuerpo | cabeza ] left->right, moving right
      snake.push({x: mid - 1, y: mid}); // cola (index 0)
      snake.push({x: mid, y: mid});     // cuerpo (index 1)
      snake.push({x: mid + 1, y: mid}); // cabeza (index 2 = snake.length-1)
      dir = {x:1,y:0}; pendingDir = null;
      spawnFood();
      score = 0; running = true;
      document.getElementById("score").textContent = score;
      if(tickHandle) clearInterval(tickHandle);
      tickHandle = setInterval(gameTick, tickInterval);
      document.getElementById("btnRestart").disabled = true;
    }

    function gameOver(){
      running=false;
      if(tickHandle){ clearInterval(tickHandle); tickHandle=null; }
      document.getElementById('btnRestart').disabled = false;
      alert("Game over — Puntaje: " + score);
    }

    function gameTick(){
      if(!running) return;
      if(pendingDir){
        if(!(pendingDir.x === -dir.x && pendingDir.y === -dir.y)) dir = pendingDir;
        pendingDir = null;
      }
      const head = snake[snake.length-1];
      const newHead = { x: head.x + dir.x, y: head.y + dir.y };
      // wall collision
      if(newHead.x < 0 || newHead.x >= GRID_SIZE || newHead.y < 0 || newHead.y >= GRID_SIZE){ gameOver(); return; }
      // self collision
      if(snake.some(s => s.x===newHead.x && s.y===newHead.y)){ gameOver(); return; }
      snake.push(newHead);
      if(food && newHead.x===food.x && newHead.y===food.y){
        score += 10; document.getElementById("score").textContent = score;
        spawnFood();
      } else {
        snake.shift();
      }
    }

    /* ---------------- draw helpers ---------------- */
    // draws currently bound texture (uUnidadDeTextura) with UV subrect selection
    // subcol/subrow select which cell in sheet (0-based)
    function drawQuadWithTexture(texture, subcol, subrow, cols, rows, modelMat, tint){
      gl.uniformMatrix4fv(uMatrizModelo, false, modelMat);
      if(texture){
        gl.uniform1f(uHasTexture, 1.0);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.uniform1i(uUnidadDeTextura, 0);
        // compute UV scale/offset (remember we flipped Y when uploading)
        const uScale = 1.0/cols, vScale = 1.0/rows;
        const uOffset = subcol * uScale;
        const vOffset = 1.0 - vScale - subrow * vScale;
        gl.uniform2f(uUVScale, uScale, vScale);
        gl.uniform2f(uUVOffset, uOffset, vOffset);
        gl.uniform4f(uColor, tint[0], tint[1], tint[2], tint[3]);
      } else {
        gl.uniform1f(uHasTexture, 0.0);
        gl.uniform4f(uColor, tint[0], tint[1], tint[2], tint[3]);
      }
      gl.bindVertexArray(quadVAO);
      gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
      gl.bindVertexArray(null);
      if(texture) gl.bindTexture(gl.TEXTURE_2D, null);
    }

    /* ---------------- main loop (draw scene) ---------------- */
function loop(){
  // clear
  gl.clearColor(0.9,0.85,0.7,1.0);
  gl.clear(gl.COLOR_BUFFER_BIT);

  // draw background full-screen 
  identidad(MatrizModelo); traslacion(MatrizModelo, 0, 0, 0); 
  escalacion(MatrizModelo, outerHalf*2, outerHalf*2, 1);
  drawQuadWithTexture(texBG, 0, 0, 1, 1, MatrizModelo, [1,1,1,1]);

  // ESCALA UNIFORME PARA TODOS LOS SEGMENTOS
  const scale = CELL_WORLD * 1.1;

  // draw snake segments: iterate 0..n-1 (0=cola, n-1=cabeza)
  for(let i=0;i<snake.length;i++){
    const seg = snake[i];
    const pos = cellToWorld(seg.x, seg.y);
    identidad(MatrizModelo); traslacion(MatrizModelo, pos.x, pos.y, 0);
    escalacion(MatrizModelo, scale, scale, 1); // ESCALA UNIFORME

    // DETERMINAR DIRECCIÓN Y FILA CORRESPONDIENTE
    let row = 0; // Por defecto: derecha
    
    if(i === snake.length - 1){
      // HEAD - dirección basada en head -> prev
      const prev = snake[i-1];
      const dx = seg.x - prev.x, dy = seg.y - prev.y;
      if(dx === 1) row = 0;       // Derecha
      else if(dx === -1) row = 1; // Izquierda
      else if(dy === -1) row = 2; // Arriba
      else if(dy === 1) row = 3;  // Abajo
      
      // HEAD siempre usa columna 2
      drawQuadWithTexture(texSheet, 2, row, sheetCols, sheetRows, MatrizModelo, [1,1,1,1]);
      
    } else if(i === 0){
      // TAIL - dirección basada en next -> tail
      const next = snake[i+1];
      const dx = next.x - seg.x, dy = next.y - seg.y;
      if(dx === 1) row = 0;       // Derecha
      else if(dx === -1) row = 1; // Izquierda
      else if(dy === -1) row = 2; // Arriba
      else if(dy === 1) row = 3;  // Abajo
      
      // TAIL siempre usa columna 0
      drawQuadWithTexture(texSheet, 0, row, sheetCols, sheetRows, MatrizModelo, [1,1,1,1]);
      
    } else {
  // BODY - dirección basada en prev -> next
  const prev = snake[i-1], next = snake[i+1];
  
  // Calcular dirección de manera más precisa
  let direction = "";
  if(next.x > prev.x) direction = "right";
  else if(next.x < prev.x) direction = "left"; 
  else if(next.y > prev.y) direction = "down";
  else if(next.y < prev.y) direction = "up";
  
  // Asignar fila según dirección
  switch(direction) {
    case "right": row = 0; break;
    case "left": row = 1; break;
    case "up": row = 2; break;
    case "down": row = 3; break;
    default: row = 0;
  }
  
  // BODY siempre usa columna 1
  drawQuadWithTexture(texSheet, 1, row, sheetCols, sheetRows, MatrizModelo, [1,1,1,1]);
}
  }

  // draw food (apple)
  if(food){
    const f = cellToWorld(food.x, food.y);
    identidad(MatrizModelo); traslacion(MatrizModelo, f.x, f.y, 0); 
    escalacion(MatrizModelo, CELL_WORLD*0.6, CELL_WORLD*0.6, 1);
    drawQuadWithTexture(texApple, 0, 0, 1, 1, MatrizModelo, [1,1,1,1]);
  }

  requestAnimationFrame(loop);
}
    /* ---------------- controls and input ---------------- */
    window.addEventListener('keydown', function(e){
      if(!running && e.key !== 'Enter') return;
      if(e.key === 'ArrowUp' || e.key === 'w'){ pendingDir = {x:0,y:-1}; e.preventDefault(); }
      else if(e.key === 'ArrowDown' || e.key === 's'){ pendingDir = {x:0,y:1}; e.preventDefault(); }
      else if(e.key === 'ArrowLeft' || e.key === 'a'){ pendingDir = {x:-1,y:0}; e.preventDefault(); }
      else if(e.key === 'ArrowRight' || e.key === 'd'){ pendingDir = {x:1,y:0}; e.preventDefault(); }
      else if(!running && e.key === 'Enter'){ resetGame(); }
    }, false);

    document.getElementById('btnRestart').addEventListener('click', function(){
      resetGame();
      this.disabled = true;
    });

  </script>
</body>
</html>


